<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShareDB - Collaborative Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.3.0/flowbite.min.js"></script>
    <style>
        .draggable {
            cursor: move;
        }
        canvas {
            cursor: crosshair;
        }
        canvas.eraser {
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-50">
    
<nav class="bg-white fixed w-full z-20 top-0 start-0 border-b border-gray-200">
  <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
    <a href="index.html" class="flex items-center space-x-3 rtl:space-x-reverse">
        <span class="self-center text-xl text-gray-900 font-semibold whitespace-nowrap">ShareDB - Collaborative Whiteboard</span>
    </a>
    <button data-collapse-toggle="navbar-default" type="button" class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5 7h14M5 12h14M5 17h14"/>
        </svg>
    </button>
    <div class="hidden w-full md:block md:w-auto" id="navbar-default">
      <ul class="font-medium flex flex-col p-4 md:p-0 mt-4 border border-gray-100 rounded-lg bg-gray-50 md:flex-row md:space-x-8 rtl:space-x-reverse md:mt-0 md:border-0 md:bg-white">
        <li>
          <a href="#" class="block py-2 px-3 text-white bg-blue-700 rounded md:bg-transparent md:text-blue-700 md:p-0" aria-current="page">Home</a>
        </li>
        <li>
          <a href="#" class="block py-2 px-3 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0">Login</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="pt-24 pb-8 px-4">
    <!-- Status Bar -->
    <div class="max-w-6xl mx-auto mb-4">
        <div class="bg-white rounded-lg shadow p-4 flex justify-between items-center">
            <div>
                <span class="text-sm text-gray-600">Status:</span>
                <span id="status" class="ml-2 font-bold text-green-600">Connecting...</span>
            </div>
            <div>
                <span class="text-sm text-gray-600">Counter:</span>
                <span id="counter" class="ml-2 font-bold text-blue-600">0</span>
                <button id="incrementBtn" class="ml-4 px-3 py-1 bg-blue-500 hover:bg-blue-700 text-white text-sm rounded">+1</button>
            </div>
        </div>
    </div>

    <!-- Whiteboard Container -->
    <div class="max-w-6xl mx-auto bg-white shadow-lg rounded-lg p-6">
        <h1 class="text-3xl font-semibold mb-6 text-center text-gray-800">
            Virtual Whiteboard
        </h1>
        
        <!-- Canvas Container -->
        <div class="border-2 border-gray-300 rounded-lg mb-6 p-4 relative bg-white">
            <div class="flex justify-center items-center">
                <canvas id="whiteboard" width="900" height="600" class="border border-gray-200 rounded"></canvas>
            </div>
            <div class="absolute top-4 right-4 flex gap-2">
                <button id="clearBtn" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition">
                    Clear All
                </button>
                <button id="eraserBtn" class="px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition">
                    Eraser
                </button>
            </div>
        </div>
        
        <!-- Tools Panel -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <!-- Drawing Tools -->
            <div class="bg-gray-50 p-4 rounded-lg">
                <label for="toolSelect" class="block text-sm font-medium text-gray-700 mb-2">
                    Drawing Tool:
                </label>
                <select id="toolSelect" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="pen">‚úèÔ∏è Pen</option>
                    <option value="line">üìè Line</option>
                    <option value="rectangle">‚¨ú Rectangle</option>
                    <option value="circle">‚≠ï Circle</option>
                    <option value="text">üìù Text</option>
                </select>
            </div>

            <!-- Color Picker -->
            <div class="bg-gray-50 p-4 rounded-lg">
                <label for="colorPicker" class="block text-sm font-medium text-gray-700 mb-2">
                    Color:
                </label>
                <div class="flex gap-2 items-center">
                    <input type="color" id="colorPicker" value="#000000" class="h-10 w-20 rounded cursor-pointer">
                    <input type="range" id="lineWidth" min="1" max="10" value="2" class="flex-1">
                    <span id="lineWidthValue" class="text-sm text-gray-600">2px</span>
                </div>
            </div>

            <!-- Actions -->
            <div class="bg-gray-50 p-4 rounded-lg flex gap-2">
                <button id="saveBtn" class="flex-1 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition">
                    üíæ Save
                </button>
                <button id="imageBtn" class="flex-1 px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition">
                    üñºÔ∏è Image
                </button>
                <input type="file" id="imageInput" accept="image/*" class="hidden">
            </div>
        </div>

        <!-- Text Input (Hidden by default) -->
        <div id="textInput" class="mb-4 hidden bg-blue-50 p-4 rounded-lg">
            <div class="flex gap-2">
                <input type="text" id="textBox" placeholder="Enter text to add to canvas..." class="flex-1 border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="textBtn" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
                    Add Text
                </button>
            </div>
        </div>
    </div>
</div>

<script src="client.bundle.js"></script>
<script>
    // Whiteboard variables
    const canvas = document.getElementById('whiteboard');
    const context = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let tool = 'pen';
    let currentColor = '#000000';
    let currentLineWidth = 2;
    let drag = false;
    let dragStartX, dragStartY;
    let localShapes = [];
    let isWhiteboardReady = false;

    // Color and line width controls
    document.getElementById('colorPicker').addEventListener('input', (e) => {
        currentColor = e.target.value;
    });

    document.getElementById('lineWidth').addEventListener('input', (e) => {
        currentLineWidth = e.target.value;
        document.getElementById('lineWidthValue').textContent = currentLineWidth + 'px';
    });

    // Redraw all shapes from ShareDB
    function redrawCanvas(shapesData) {
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!shapesData || !Array.isArray(shapesData)) return;
        
        shapesData.forEach(shape => {
            context.strokeStyle = shape.color || '#000';
            context.fillStyle = shape.color || '#000';
            context.lineWidth = shape.width || 2;
            
            if (shape.type === 'line') {
                context.beginPath();
                context.moveTo(shape.startX, shape.startY);
                context.lineTo(shape.endX, shape.endY);
                context.stroke();
            } else if (shape.type === 'rectangle') {
                context.beginPath();
                context.rect(shape.startX, shape.startY,
                    shape.endX - shape.startX,
                    shape.endY - shape.startY);
                context.stroke();
            } else if (shape.type === 'circle') {
                context.beginPath();
                context.arc(shape.startX, shape.startY,
                    shape.radius, 0, Math.PI * 2);
                context.stroke();
            } else if (shape.type === 'text') {
                context.font = '16px Arial';
                context.fillText(shape.text, shape.x, shape.y);
            } else if (shape.type === 'pen') {
                // Draw pen strokes
                if (shape.points && shape.points.length > 1) {
                    context.beginPath();
                    context.moveTo(shape.points[0].x, shape.points[0].y);
                    for (let i = 1; i < shape.points.length; i++) {
                        context.lineTo(shape.points[i].x, shape.points[i].y);
                    }
                    context.stroke();
                }
            }
        });
    }

    // Mouse events
    let currentPenStroke = null;

    canvas.addEventListener('mousedown', (e) => {
        if (!isWhiteboardReady) {
            alert('Whiteboard not ready yet. Please wait for connection.');
            return;
        }
        
        isDrawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
        
        if (tool === 'pen') {
            context.beginPath();
            context.moveTo(lastX, lastY);
            // Start a new pen stroke
            currentPenStroke = {
                type: 'pen',
                points: [{x: lastX, y: lastY}],
                color: currentColor,
                width: currentLineWidth
            };
        }
        
        if (tool === 'line' || tool === 'rectangle' || tool === 'circle') {
            drag = true;
            dragStartX = e.offsetX;
            dragStartY = e.offsetY;
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDrawing) return;
        
        const { offsetX, offsetY } = e;
        
        if (tool === 'pen') {
            context.lineWidth = currentLineWidth;
            context.strokeStyle = currentColor;
            context.lineTo(offsetX, offsetY);
            context.stroke();
            
            // Add point to current stroke
            if (currentPenStroke) {
                currentPenStroke.points.push({x: offsetX, y: offsetY});
            }
        } else if (tool === 'eraser') {
            context.clearRect(offsetX - 10, offsetY - 10, 20, 20);
        } else if ((tool === 'line' || tool === 'rectangle' || tool === 'circle') && drag) {
            redrawCanvas(window.whiteboardDoc?.data?.shapes || localShapes);
            
            context.strokeStyle = currentColor;
            context.lineWidth = currentLineWidth;
            
            if (tool === 'line') {
                context.beginPath();
                context.moveTo(lastX, lastY);
                context.lineTo(offsetX, offsetY);
                context.stroke();
            } else if (tool === 'rectangle') {
                context.beginPath();
                context.rect(lastX, lastY, offsetX - lastX, offsetY - lastY);
                context.stroke();
            } else if (tool === 'circle') {
                const radius = Math.sqrt(Math.pow(offsetX - lastX, 2) +
                    Math.pow(offsetY - lastY, 2));
                context.beginPath();
                context.arc(lastX, lastY, radius, 0, Math.PI * 2);
                context.stroke();
            }
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (!isDrawing) return;
        
        if (tool === 'pen' && currentPenStroke) {
            // Submit the complete pen stroke
            if (window.whiteboardDoc && window.whiteboardDoc.type) {
                const shapes = window.whiteboardDoc.data.shapes || [];
                window.whiteboardDoc.submitOp([{
                    p: ['shapes', shapes.length],
                    li: currentPenStroke
                }], (error) => {
                    if (error) console.error('Error submitting pen stroke:', error);
                });
            }
            currentPenStroke = null;
        } else if (tool === 'line' || tool === 'rectangle' || tool === 'circle') {
            const newShape = {
                type: tool,
                startX: dragStartX,
                startY: dragStartY,
                endX: e.offsetX,
                endY: e.offsetY,
                radius: Math.sqrt(Math.pow(e.offsetX - dragStartX, 2) +
                        Math.pow(e.offsetY - dragStartY, 2)),
                color: currentColor,
                width: currentLineWidth
            };
            
            // Submit to ShareDB
            if (window.whiteboardDoc && window.whiteboardDoc.type) {
                const shapes = window.whiteboardDoc.data.shapes || [];
                window.whiteboardDoc.submitOp([{
                    p: ['shapes', shapes.length],
                    li: newShape
                }], (error) => {
                    if (error) console.error('Error submitting shape:', error);
                });
            } else {
                localShapes.push(newShape);
            }
        }
        
        isDrawing = false;
        drag = false;
    });

    // Tool buttons
    document.getElementById('clearBtn').addEventListener('click', () => {
        if (!isWhiteboardReady) {
            alert('Whiteboard not ready yet. Please wait for connection.');
            return;
        }
        
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Clear in ShareDB
        if (window.whiteboardDoc && window.whiteboardDoc.type) {
            const currentShapes = window.whiteboardDoc.data.shapes || [];
            if (currentShapes.length > 0) {
                window.whiteboardDoc.submitOp([
                    { p: ['shapes'], od: currentShapes, oi: [] }
                ], (error) => {
                    if (error) console.error('Error clearing whiteboard:', error);
                });
            }
        } else {
            localShapes = [];
        }
    });

    document.getElementById('eraserBtn').addEventListener('click', () => {
        tool = 'eraser';
        canvas.classList.add('eraser');
    });

    document.getElementById('toolSelect').addEventListener('change', (e) => {
        tool = e.target.value;
        canvas.classList.remove('eraser');
        
        if (tool === 'text') {
            document.getElementById('textInput').classList.remove('hidden');
            document.getElementById('textBox').focus();
        } else {
            document.getElementById('textInput').classList.add('hidden');
        }
    });

    // Text tool
    document.getElementById('textBtn').addEventListener('click', () => {
        const text = document.getElementById('textBox').value;
        if (text && isWhiteboardReady) {
            const textShape = {
                type: 'text',
                text: text,
                x: lastX || 100,
                y: lastY || 100,
                color: currentColor
            };
            
            context.font = '16px Arial';
            context.fillStyle = currentColor;
            context.fillText(text, textShape.x, textShape.y);
            
            // Submit to ShareDB
            if (window.whiteboardDoc && window.whiteboardDoc.type) {
                const shapes = window.whiteboardDoc.data.shapes || [];
                window.whiteboardDoc.submitOp([{
                    p: ['shapes', shapes.length],
                    li: textShape
                }], (error) => {
                    if (error) console.error('Error submitting text:', error);
                });
            }
            
            document.getElementById('textBox').value = '';
            document.getElementById('textInput').classList.add('hidden');
            tool = 'pen';
        }
    });

    // Image upload
    document.getElementById('imageBtn').addEventListener('click', () => {
        document.getElementById('imageInput').click();
    });

    document.getElementById('imageInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = () => {
            const img = new Image();
            img.onload = () => {
                context.drawImage(img, 0, 0, Math.min(img.width, canvas.width), Math.min(img.height, canvas.height));
            };
            img.src = reader.result;
        };
        reader.readAsDataURL(file);
    });

    // Save canvas
    document.getElementById('saveBtn').addEventListener('click', () => {
        const image = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = image;
        link.download = 'whiteboard-' + Date.now() + '.png';
        link.click();
    });

    // Make whiteboard doc available globally for integration
    window.initWhiteboard = function(doc) {
        console.log('Initializing whiteboard with ShareDB document...');
        window.whiteboardDoc = doc;
        
        // Listen for changes from other users
        doc.on('op', (op, source) => {
            if (!source) {
                // This operation came from another user
                console.log('Received operation from another user:', op);
                if (doc.data && doc.data.shapes) {
                    redrawCanvas(doc.data.shapes);
                }
            }
        });
        
        // Initial render
        if (doc.data && doc.data.shapes) {
            redrawCanvas(doc.data.shapes);
        }
        
        isWhiteboardReady = true;
        console.log('Whiteboard ready!');
    };
</script>

</body>
</html>